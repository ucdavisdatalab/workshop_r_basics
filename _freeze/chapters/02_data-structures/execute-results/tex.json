{
  "hash": "4511bac5079433f14e78fadf9b81ee49",
  "result": {
    "engine": "knitr",
    "markdown": "# Data Structures\n\n:::{.callout-note}\n##### Learning Goals\n\nAfter completing this chapter, learners should be able to:\n\n* Create vectors, including sequences\n* Identify whether a function is vectorized or not\n* Check the type and class of an object\n* Coerce an object to a different type\n* Describe matrices and lists\n* Describe and differentiate `NA`, `NaN`, `Inf`, `NULL`\n* Identify, create, and relevel factors\n* Index vectors with empty, integer, string, and logical arguments\n* Negate or combine conditions with logic operators\n:::\n\nThe previous chapter introduced R and gave you enough background to do some\nsimple computations on data sets. This chapter focuses on the foundational\nknowledge and skills you'll need in order to use R effectively in the long\nterm. Specifically, it begins with a deep dive into R's various data structures\nand data types, then explains a variety of ways to get and set their elements.\n\n\n## Vectors {#sec-vectors}\n\n\n::: {.cell}\n\n:::\n\n\nA **vector** is a collection of values. Vectors are the fundamental unit of\ndata in R, and you've already used them in the previous sections.\n\nFor instance, each column in a data frame is a vector. So the `site_name`\ncolumn in the California least terns data set (@sec-ca-least-terns) is a\nvector. Take a look at it now. You can use `head` to avoid printing too much.\nSet the second argument to `10` so that exactly 10 values are printed:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(terns$site_name, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"PITTSBURG POWER PLANT\"                       \n [2] \"ALBANY CENTRAL AVE\"                          \n [3] \"ALAMEDA POINT\"                               \n [4] \"KETTLEMAN CITY\"                              \n [5] \"OCEANO DUNES STATE VEHICULAR RECREATION AREA\"\n [6] \"RANCHO GUADALUPE DUNES PRESERVE\"             \n [7] \"VANDENBERG SFB\"                              \n [8] \"SANTA CLARA RIVER MCGRATH STATE BEACH\"       \n [9] \"ORMOND BEACH\"                                \n[10] \"NBVC POINT MUGU\"                             \n```\n\n\n:::\n:::\n\n\nLike all vectors, this vector is **ordered**, which just means the values, or\n**elements**, have specific positions. The value of the 1st element is `r\nterns$site_name[[1]]`, the 2nd is ALBANY CENTRAL AVE, the 5th is `r\nterns$site_name[[5]]`, and so on.\n\nNotice that the elements of this vector are all strings. In R, the elements of\na vector must all be the same type of data (we say the elements are\n**homogeneous**). A vector can contain integers, decimal numbers, strings, or\nany of several other types of data, but not a mix these all at once.\n\nThe other columns in the least terns data frame are also vectors. For instance,\nthe `year` column is a vector of integers:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(terns$year)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2000 2000 2000 2000 2000 2000\n```\n\n\n:::\n:::\n\n\nVectors can contain any number of elements, including 0 or 1 element. Unlike\nmathematics, R does not distinguish between vectors and scalars (solitary\nvalues). As far as R is concerned, a solitary value, like `3`, is a vector with\n1 element.\n\nYou can check the length of a vector (and other objects) with the `length`\nfunction:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(\"hello\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(terns$year)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 791\n```\n\n\n:::\n:::\n\n\nSince the last of these is a column from the data frame `terns`, the length is\nthe same as the number of rows in `terns`.\n\n\n### Creating Vectors\n\nSometimes you'll want to create your own vectors. You can do this by\nconcatenating several vectors together with the `c` function. It accepts any\nnumber of vector arguments, and combines them into a single vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, 2, 19, -3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  2 19 -3\n```\n\n\n:::\n\n```{.r .cell-code}\nc(\"hi\", \"hello\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hi\"    \"hello\"\n```\n\n\n:::\n\n```{.r .cell-code}\nc(1, 2, c(3, 4))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4\n```\n\n\n:::\n:::\n\n\nIf the arguments you pass to the `c` function have different data types, R will\nattempt to convert them to a common data type that preserves the information:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, \"cool\", 2.3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1\"    \"cool\" \"2.3\" \n```\n\n\n:::\n:::\n\n\n@sec-implicit-coercion explains the rules for this conversion in more detail.\n\nThe colon operator `:` creates vectors that contain sequences of integers. This\nis useful for creating \"toy\" data to test things on, and later we'll see that\nit's also important in several other contexts. Here are a few different\nsequences:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\n-3:5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -3 -2 -1  0  1  2  3  4  5\n```\n\n\n:::\n\n```{.r .cell-code}\n10:1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 10  9  8  7  6  5  4  3  2  1\n```\n\n\n:::\n:::\n\n\nBeware that both endpoints are included in the sequence, even in sequences like\n`1:0`, and that the difference between elements is always `-1` or `1`. If you\nwant more control over the generated sequence, use the `seq` function instead.\n\n\n### Indexing Vectors {#sec-indexing-vectors}\n\nYou can access individual elements of a vector with the **indexing operator**\n`[` (also called the square bracket operator). The syntax is:\n\n```\nVECTOR[INDEXES]\n```\n\nHere `INDEXES` is a vector of positions of elements you want to get or set.\n\nFor example, let's make a vector with 5 elements and get the 2nd element:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(4, 8, 3, 2, 1)\nx[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8\n```\n\n\n:::\n:::\n\n\nNow let's get the 3rd and 1st element:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[c(3, 1)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 4\n```\n\n\n:::\n:::\n\n\nYou can use the indexing operator together with the assignment operator to\nassign elements of a vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[3] = 0\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 8 0 2 1\n```\n\n\n:::\n:::\n\n\nIndexing is among the most frequently used operations in R, so take some time\nto try it out with few different vectors and indexes. We'll revisit indexing in\n@sec-indexing to learn a lot more about it.\n\n\n### Vectorization {#sec-vectorization}\n\nLet's look at what happens if we call a mathematical function, like `sin`, on a\nvector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(1, 3, 0, pi)\nsin(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8.414710e-01 1.411200e-01 0.000000e+00 1.224647e-16\n```\n\n\n:::\n:::\n\n\nThis gives us the same result as if we had called the function separately on\neach element. That is, the result is the same as:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(sin(1), sin(3), sin(0), sin(pi))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8.414710e-01 1.411200e-01 0.000000e+00 1.224647e-16\n```\n\n\n:::\n:::\n\n\nOf course, the first version is much easier to type.\n\nFunctions that take a vector argument and get applied element-by-element like\nthis are said to be **vectorized**. Most functions in R are vectorized,\nespecially math functions. Some examples include `sin`, `cos`, `tan`, `log`,\n`exp`, and `sqrt`.\n\nFunctions that are not vectorized tend to be ones that combine or aggregate\nvalues in some way. For instance, the `sum`, `mean`, `median`, `length`, and\n`class` functions are not vectorized.\n\nA function can be vectorized across multiple arguments. This is easiest to\nunderstand in terms of the arithmetic operators. Let's see what happens if we\nadd two vectors together:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(1, 2, 3, 4)\ny = c(-1, 7, 10, -10)\nx + y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  0  9 13 -6\n```\n\n\n:::\n:::\n\n\nThe elements are paired up and added according to their positions. The other\narithmetic operators are also vectorized:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx - y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2 -5 -7 14\n```\n\n\n:::\n\n```{.r .cell-code}\nx * y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  -1  14  30 -40\n```\n\n\n:::\n\n```{.r .cell-code}\nx / y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -1.0000000  0.2857143  0.3000000 -0.4000000\n```\n\n\n:::\n:::\n\n\n### Recycling {#sec-recycling}\n\nWhen a function is vectorized across multiple arguments, what happens if the\nvectors have different lengths? Whenever you think of a question like this as\nyou're learning R, the best way to find out is to create some toy data and test\nit yourself. Let's try that now:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(1, 2, 3, 4)\ny = c(-1, 1)\nx + y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0 3 2 5\n```\n\n\n:::\n:::\n\n\nThe elements of the shorter vector are **recycled** to match the length of the\nlonger vector. That is, after the second element, the elements of `y` are\nrepeated to make a vector with the same length as `x` (because `x` is longer),\nand then vectorized addition is carried out as usual.\n\nHere's what that looks like written down:\n\n```\n   1  2  3  4\n+ -1  1 -1  1\n  -----------\n   0  3  2  5\n```\n\nIf the length of the longer vector is not a multiple of the length of the\nshorter vector, R issues a warning, but still returns the result. The warning\nas meant as a reminder, because unintended recycling is a common source of\nbugs:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(1, 2, 3, 4, 5)\ny = c(-1, 1)\nx + y\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in x + y: longer object length is not a multiple of shorter object\nlength\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0 3 2 5 4\n```\n\n\n:::\n:::\n\n\nRecycling might seem strange at first, but it's convenient if you want to use a\nspecific value (or pattern of values) with a vector. For instance, suppose you\nwant to multiply all the elements of a vector by `2`. Recycling makes this\neasy:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2 * c(1, 2, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 4 6\n```\n\n\n:::\n:::\n\n\nWhen you use recycling, most of the time one of the arguments will be a scalar\nlike this.\n\n\n## Data Types & Classes {#sec-data-types-classes}\n\nData can be categorized into different **types** based on sets of shared\ncharacteristics. For instance, statisticians tend to think about whether data\nare numeric or categorical:\n\n* numeric\n    + continuous (real or complex numbers)\n    + discrete (integers)\n* categorical\n    + nominal (categories with no ordering)\n    + ordinal (categories with some ordering)\n\nOf course, other types of data, like graphs (networks) and natural language\n(books, speech, and so on), are also possible. Categorizing data this way is\nuseful for reasoning about which methods to apply to which data.\n\nIn R, data objects are categorized in two different ways:\n\n1. The **class** of an R object describes what the object does, or the role\n   that it plays. Sometimes objects can do more than one thing, so objects can\n   have more than one class. The `class` function, which debuted\n   in @sec-data-frames, returns the classes of its argument.\n\n2. The **type** of an R object describes what the object is. Technically, the\n   type corresponds to how the object is stored in your computer's memory. Each\n   object has exactly one type. The `typeof` function returns the type of its\n   argument.\n\nOf the two, classes tend to be more important than types. If you aren't sure\nwhat an object is, checking its classes should be the first thing you do.\n\nThe built-in classes you'll use all the time correspond to vectors and lists\n(which we'll learn more about in @sec-lists):\n\n| Class     | Example               | Description\n| :----     | :------               | :----------\n| logical   | `TRUE`, `FALSE`       | Logical (or Boolean) values\n| integer   | `-1L`, `1L`, `2L`     | Integer numbers\n| numeric   | `-2.1`, `7`, `34.2`   | Real numbers\n| complex   | `3-2i`, `-8+0i`       | Complex numbers\n| character | `\"hi\"`, `\"YAY\"`       | Text strings\n| list      | `list(TRUE, 1, \"hi\")` | Ordered collection of heterogeneous elements\n\nR doesn't distinguish between scalars and vectors, so the class of a vector is\nthe same as the class of its elements:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(\"hi\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(c(\"hello\", \"hi\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\nIn addition, for most vectors, the class and the type are the same:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(TRUE, FALSE)\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n:::\n\n\nThe exception to this rule is numeric vectors, which have type `double` for\nhistorical reasons:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(pi)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(pi)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n:::\n\n\nThe word \"double\" here stands for [double-precision floating point\nnumber][double], a standard way to represent real numbers on computers.\n\n[double]: https://en.wikipedia.org/wiki/Double-precision_floating-point_format\n\nBy default, R assumes any numbers you enter in code are numeric, even if\nthey're integer-valued.\n\nThe class `integer` also represents integer numbers, but it's not used as often\nas `numeric`. A few functions, such as the sequence operator `:` and the\n`length` function, return integers. You can also force R to create an integer\nby adding the suffix `L` to a number, but there are no major drawbacks to using\nthe `double` default:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(1:3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(3L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n\nBesides the classes for vectors and lists, there are several built-in classes\nthat represent more sophisticated data structures:\n\n| Class      | Description\n| :----      | :----------\n| function   | Functions\n| factor     | Categorical values\n| matrix     | Two-dimensional ordered collection of homogeneous elements\n| array      | Multi-dimensional ordered collection of homogeneous elements\n| data.frame | Data frames\n\nFor these, the class is usually different from the type. We'll learn more about\nmost of these later on.\n\n\n### Lists {#sec-lists}\n\nA **list** is an ordered data structure where the elements can have different\ntypes (they are **heterogeneous**). This differs from a vector, where the\nelements all have to have the same type, as we saw in @sec-vectors. The\ntradeoff is that most vectorized functions do not work with lists.\n\nYou can make an ordinary list with the `list` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = list(1, c(\"hi\", \"bye\"))\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n:::\n\n\nFor ordinary lists, the type and the class are both `list`. In @sec-indexing,\nwe'll learn how to get and set list elements, and in later sections we'll learn\nmore about when and why to use lists.\n\nYou've already seen one list, the `terns` data frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(terns)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(terns)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n:::\n\n\nUnder the hood, data frames are lists, and each column is a list element.\nBecause the class is `data.frame` rather than `list`, R treats data frames\ndifferently from ordinary lists. This difference is apparent in how data frames\nare printed compared to ordinary lists.\n\n\n### Implicit Coercion {#sec-implicit-coercion}\n\nR's types fall into a natural hierarchy of expressiveness:\n\n![R's hierarchy of types.](/images/types.png)\n\nEach type on the right is more expressive than the ones to its left. That is,\nwith the convention that `FALSE` is `0` and `TRUE` is `1`, we can represent any\nlogical value as an integer. In turn, we can represent any integer as a double,\nand any double as a complex number. By writing the number out, we can also\nrepresent any complex number as a string.\n\nThe point is that no information is lost as we follow the arrows from left to\nright along the types in the hierarchy. In fact, R will automatically and\nsilently convert from types on the left to types on the right as needed. This\nis called **implicit coercion**.\n\nAs an example, consider what happens if we add a logical value to a number:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRUE + 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\nR automatically converts the `TRUE` to the numeric value `1`, and then carries\nout the arithmetic as usual.\n\nWe've already seen implicit coercion at work once before, when we learned the\n`c` function. Since the elements of a vector all have to have the same type, if\nyou pass several different types to `c`, then R tries to use implicit coercion\nto make them the same:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(TRUE, \"hi\", 1, 1+3i)\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"TRUE\" \"hi\"   \"1\"    \"1+3i\"\n```\n\n\n:::\n:::\n\n\nImplicit coercion is strictly one-way; it never occurs in the other direction.\nIf you want to coerce a type on the right to one on the left, you can do it\nexplicitly with one of the `as.TYPE` functions. For instance, the `as.numeric`\n(or `as.double`) function coerces to numeric:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.numeric(\"3.1\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.1\n```\n\n\n:::\n:::\n\n\nThere are a few types that fall outside of the hierarchy entirely, like\nfunctions. Implicit coercion doesn't apply to these. If you try to use these\ntypes where it doesn't make sense to, R generally returns an error:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsin + 3\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in sin + 3: non-numeric argument to binary operator\n```\n\n\n:::\n:::\n\n\nIf you try to use these types as elements of a vector, you get back a list\ninstead:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(1, 2, sum)\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n:::\n\n\nUnderstanding how implicit coercion works will help you avoid bugs, and can\nalso be a time-saver. For example, we can use implicit coercion to succinctly\ncount how many elements of a vector satisfy a some condition:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(1, 3, -1, 10, -2, 3, 8, 2)\ncondition = x < 4\nsum(condition)    # or sum(x < 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n:::\n\n\nIf you still don't quite understand how the code above works, try inspecting\neach variable. In general, inspecting each step or variable is a good strategy\nfor understanding why a piece of code works (or doesn't work!). Here the\nimplicit coercion happens in the third line.\n\n\n### Matrices & Arrays\n\nA **matrix** is the two-dimensional analogue of a vector. The elements, which\nare arranged into rows and columns, are ordered and homogeneous.\n\nYou can create a matrix from a vector with the `matrix` function. By default,\nthe columns are filled first:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# A matrix with 2 rows and 3 columns:\nmatrix(1:6, 2, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n\n\n:::\n:::\n\n\nThe class of a matrix is always `matrix`, and the type matches the type of the\nelements:\n\n::: {.cell}\n\n```{.r .cell-code}\nx = matrix(c(\"a\", \"b\", NA, \"c\"), 2, 2)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,] \"a\"  NA  \n[2,] \"b\"  \"c\" \n```\n\n\n:::\n\n```{.r .cell-code}\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"matrix\" \"array\" \n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\nYou can use the matrix multiplication operator `%*%` to multiply two matrices\nwith compatible dimensions.\n\nAn **array** is a further generalization of matrices to higher dimensions. You\ncan create an array from a vector with the `array` function. The\ncharacteristics of arrays are almost identical to matrices, but the class of an\narray is always `array`.\n\n\n### Factors\n\nA feature is **categorical** if it measures a qualitative category. For\nexample, the genres `rock`, `blues`, `alternative`, `folk`, `pop` are\ncategories.\n\nR uses the class `factor` to represent categorical data. Visualizations and\nstatistical models sometimes treat factors differently than other data types,\nso it's important to make sure you have the right data type. If you're ever\nunsure, remember that you can check the class of an object with the `class`\nfunction.\n\nWhen it reads a data set, R usually can't tell which features are categorical.\nThat means identifying and converting the categorical features is up to you.\nFor beginners, it can be difficult to understand whether a feature is\ncategorical or not. The key is to think about whether you want to use the\nfeature to divide the data into groups.\n\nFor example, if you want to know how many songs are in the `rock` genre, you\nfirst need to divide the songs by genre, and then count the number of songs in\neach group (or at least the `rock` group).\n\nAs a second example, months recorded as numbers can be categorical or not,\ndepending on how you want to use them. You might want to treat them as\ncategorical (for example, to compute max rainfall in each month) or you might\nwant to treat them as numbers (for example, to compute the number of months\ntime between two events).\n\nThe bottom line is that you have to think about what you'll be doing in the\nanalysis. In some cases, you might treat a feature as categorical only for part\nof the analysis.\n\nLet's think about which features are categorical in least terns data set. To\nrefresh your memory of what's in the data set, take a look at the structural\nsummary:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(terns)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t791 obs. of  43 variables:\n $ year               : int  2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 ...\n $ site_name          : chr  \"PITTSBURG POWER PLANT\" \"ALBANY CENTRAL AVE\" \"ALAMEDA POINT\" \"KETTLEMAN CITY\" ...\n $ site_name_2013_2018: chr  \"Pittsburg Power Plant\" \"NA_NO POLYGON\" \"Alameda Point\" \"Kettleman\" ...\n $ site_name_1988_2001: chr  \"NA_2013_2018 POLYGON\" \"Albany Central Avenue\" \"NA_2013_2018 POLYGON\" \"NA_2013_2018 POLYGON\" ...\n $ site_abbr          : chr  \"PITT_POWER\" \"AL_CENTAVE\" \"ALAM_PT\" \"KET_CTY\" ...\n $ region_3           : chr  \"S.F._BAY\" \"S.F._BAY\" \"S.F._BAY\" \"KINGS\" ...\n $ region_4           : chr  \"S.F._BAY\" \"S.F._BAY\" \"S.F._BAY\" \"KINGS\" ...\n $ event              : chr  \"LA_NINA\" \"LA_NINA\" \"LA_NINA\" \"LA_NINA\" ...\n $ bp_min             : num  15 6 282 2 4 9 30 21 73 166 ...\n $ bp_max             : num  15 12 301 3 5 9 32 21 73 167 ...\n $ fl_min             : int  16 1 200 1 4 17 11 9 60 64 ...\n $ fl_max             : int  18 1 230 2 4 17 11 9 65 64 ...\n $ total_nests        : int  15 20 312 3 5 9 32 22 73 252 ...\n $ nonpred_eggs       : int  3 NA 124 NA 2 0 NA 4 2 NA ...\n $ nonpred_chicks     : int  0 NA 81 3 0 1 27 3 0 NA ...\n $ nonpred_fl         : int  0 NA 2 1 0 0 0 NA 0 NA ...\n $ nonpred_ad         : int  0 NA 1 6 0 0 0 NA 0 NA ...\n $ pred_control       : chr  \"\" \"\" \"\" \"\" ...\n $ pred_eggs          : int  4 NA 17 NA 0 NA 0 NA NA NA ...\n $ pred_chicks        : int  2 NA 0 NA 4 NA 3 NA NA NA ...\n $ pred_fl            : int  0 NA 0 NA 0 NA 0 NA NA NA ...\n $ pred_ad            : int  0 NA 0 NA 0 NA 0 NA NA NA ...\n $ pred_pefa          : chr  \"N\" \"\" \"N\" \"\" ...\n $ pred_coy_fox       : chr  \"N\" \"\" \"N\" \"\" ...\n $ pred_meso          : chr  \"N\" \"\" \"N\" \"\" ...\n $ pred_owlspp        : chr  \"N\" \"\" \"N\" \"\" ...\n $ pred_corvid        : chr  \"Y\" \"\" \"N\" \"\" ...\n $ pred_other_raptor  : chr  \"Y\" \"\" \"Y\" \"\" ...\n $ pred_other_avian   : chr  \"N\" \"\" \"Y\" \"\" ...\n $ pred_misc          : chr  \"N\" \"\" \"N\" \"\" ...\n $ total_pefa         : int  0 NA 0 NA 0 NA 0 NA NA NA ...\n $ total_coy_fox      : int  0 NA 0 NA 0 NA 0 NA NA NA ...\n $ total_meso         : int  0 NA 0 NA 0 NA 0 NA NA NA ...\n $ total_owlspp       : int  0 NA 0 NA 0 NA 0 NA NA NA ...\n $ total_corvid       : int  4 NA 0 NA 0 NA 0 NA NA NA ...\n $ total_other_raptor : int  2 NA 6 NA 0 NA 3 NA NA NA ...\n $ total_other_avian  : int  0 NA 11 NA 4 NA 0 NA NA NA ...\n $ total_misc         : int  0 NA 0 NA 0 NA 0 NA NA NA ...\n $ first_observed     : chr  \"2000-05-11\" \"\" \"2000-05-01\" \"2000-06-10\" ...\n $ last_observed      : chr  \"2000-08-05\" \"\" \"2000-08-19\" \"2000-09-24\" ...\n $ first_nest         : chr  \"2000-05-26\" \"\" \"2000-05-16\" \"2000-06-17\" ...\n $ first_chick        : chr  \"2000-06-18\" \"\" \"2000-06-07\" \"2000-07-22\" ...\n $ first_fledge       : chr  \"2000-07-08\" \"\" \"2000-06-30\" \"2000-08-06\" ...\n```\n\n\n:::\n:::\n\n\nThe `site_name`, `site_abbr`, and `event` columns are all examples of\ncategorical data. The `region_` columns and some of the `pred_` columns also\ncontain categorical data.\n\nOne way to check whether a feature is useful for grouping (and thus effectively\ncategorical) is to count the number of times each value appears. You can do\nthis with the `table` function. For instance, to count the number of times each\ncategory of `event` appears:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(terns$event)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nEL_NINO LA_NINA NEUTRAL \n    120     258     413 \n```\n\n\n:::\n:::\n\n\nFeatures with only a few unique values, repeated many times, are ideal for\ngrouping. Numerical features, like `total_nests`, usually aren't good for\ngrouping, both because of what they measure and because they tend to have many\nunique values, which leads to very small groups.\n\nThe `year` column can be treated as categorical or quantitative data. It's easy\nto imagine grouping observations by year, but years are also numerical: they\nhave an order and we might want to do math on them. The most appropriate type\nfor `year` depends on how we want to use it for analysis.\n\nYou can convert a column to the `factor` class with the `factor` function. Try\nthis for the `event` column:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nevent = factor(terns$event)\nevent\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1] LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA\n [10] LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA\n [19] LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA\n [28] LA_NINA LA_NINA NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n [37] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n [46] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n [55] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n [64] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n [73] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n [82] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n [91] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[100] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[109] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[118] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[127] NEUTRAL EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO\n[136] EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO\n[145] EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO\n[154] EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO\n[163] EL_NINO EL_NINO LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA\n[172] LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA\n[181] LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA\n[190] LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA\n[199] LA_NINA LA_NINA LA_NINA LA_NINA NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[208] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[217] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[226] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[235] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL EL_NINO\n[244] EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO\n[253] EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO\n[262] EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO\n[271] EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO\n[280] EL_NINO EL_NINO EL_NINO LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA\n[289] LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA\n[298] LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA\n[307] LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA\n[316] LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA\n[325] LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA\n[334] LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA\n[343] LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA\n[352] LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA\n[361] LA_NINA LA_NINA LA_NINA LA_NINA NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[370] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[379] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[388] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[397] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[406] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[415] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[424] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[433] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[442] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[451] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[460] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[469] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[478] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[487] NEUTRAL NEUTRAL NEUTRAL NEUTRAL EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO\n[496] EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO\n[505] EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO\n[514] EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO\n[523] EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO EL_NINO\n[532] EL_NINO EL_NINO NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[541] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[550] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[559] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[568] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[577] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[586] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[595] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[604] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[613] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[622] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[631] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[640] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[649] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[658] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[667] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL\n[676] NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL NEUTRAL LA_NINA LA_NINA\n[685] LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA\n[694] LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA\n[703] LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA\n[712] LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA\n[721] LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA\n[730] LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA\n[739] LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA\n[748] LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA\n[757] LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA\n[766] LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA\n[775] LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA\n[784] LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA LA_NINA\nLevels: EL_NINO LA_NINA NEUTRAL\n```\n\n\n:::\n:::\n\n\nNotice that factors are printed differently than strings.\n\nThe categories of a factor are called **levels**. You can list the levels with\nthe `levels` function:\n\n::: {.cell}\n\n```{.r .cell-code}\nlevels(event)\n```\n:::\n\n\nA factor remembers all possible levels even if you take a subset where some of\nthe levels aren't present:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nevent[1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] LA_NINA LA_NINA LA_NINA\nLevels: EL_NINO LA_NINA NEUTRAL\n```\n\n\n:::\n\n```{.r .cell-code}\nlevels(event[1:3])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"EL_NINO\" \"LA_NINA\" \"NEUTRAL\"\n```\n\n\n:::\n:::\n\n\nThis is an important way factors are different from strings (or `character`\nvectors). It ensures that if you plot a factor, the missing levels will still\nbe represented on the plot.\n\n:::{.callout-tip}\nYou can make a factor forget levels that aren't present with the `droplevels`\nfunction:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndroplevels(event[1:3])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] LA_NINA LA_NINA LA_NINA\nLevels: LA_NINA\n```\n\n\n:::\n:::\n\n:::\n\n\n## Special Values\n\nR has four special values to represent missing or invalid data.\n\n### Missing Values {#sec-missing-values}\n\nThe value `NA`, called the **missing value**, represents missing entries in a\ndata set. It's implied that the entries are missing due to how the data was\ncollected, although there are exceptions. As an example, imagine the data came\nfrom a survey, and respondents chose not to answer some questions. In the data\nset, their answers for those questions can be recorded as `NA`.\n\nThe missing value is a chameleon: it can be a logical, integer, numeric,\ncomplex, or character value. By default, the missing value is logical, and the\nother types occur through coercion (@sec-implicit-coercion):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(c(1, NA))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(c(\"hi\", NA, NA))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\nThe missing value is also contagious: it represents an unknown quantity, so\nusing it as an argument to a function usually produces another missing value.\nThe idea is that if the inputs to a computation are unknown, generally so is\nthe output:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNA - 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(c(1, 2, NA))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\nAs a consequence, testing whether an object is equal to the missing value with\n`==` doesn't return a meaningful result:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n5 == NA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nNA == NA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\nYou can use the `is.na` function instead:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.na(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.na(NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.na(c(1, NA, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\nMissing values are a feature that sets R apart from most other programming\nlanguages.\n\n\n### Infinity\n\nThe value `Inf` represents infinity, and can be numeric or complex. You're most\nlikely to encounter it as the result of certain computations:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n13 / 0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Inf\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(Inf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\nYou can use the `is.infinite` function to test whether a value is infinite:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.infinite(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.infinite(c(-Inf, 0, Inf))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE  TRUE\n```\n\n\n:::\n:::\n\n\n### Not a Number\n\nThe value `NaN` (\"not a number\") represents a quantity that's undefined\nmathematically. For instance, dividing 0 by 0 is undefined:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n0 / 0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NaN\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(NaN)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\nLike `Inf`, `NaN` can be numeric or complex.\n\nYou can use the `is.nan` function to test whether a value is `NaN`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.nan(c(10.1, log(-1), 3))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in log(-1): NaNs produced\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n\n### Null\n\nThe value `NULL` represents a quantity that's undefined in R. Most of the time,\n`NULL` indicates the absence of a result. For instance, vectors don't have\ndimensions, so the `dim` function returns `NULL` for vectors:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(c(1, 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(NULL)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"NULL\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(NULL)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"NULL\"\n```\n\n\n:::\n:::\n\n\nUnlike the other special values, `NULL` has its own unique type and class.\n\nYou can use the `is.null` function to test whether a value is `NULL`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.null(\"null\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.null(NULL)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n## Indexing {#sec-indexing}\n\nThe way to get and set elements of a data structure is by **indexing**.\nSometimes this is also called **subsetting** or (element) **extraction**.\nIndexing is a fundamental operation in R, key to reasoning about how to solve\nproblems with the language.\n\nWe first saw indexing in @sec-data-frames, where we used `$`, the dollar sign\noperator, to get and set data frame columns. We saw indexing again in\n@sec-indexing-vectors, where we used `[`, the indexing or square bracket\noperator, to get and set elements of vectors.\n\nThe indexing operator `[` is R's primary operator for indexing. It works in\nfour different ways, depending on the type of the index you use. These four\nways to select elements are:\n\n1. All elements, with no index\n2. By position, with a numeric index\n3. By name, with a character index\n4. By condition, with a logical index\n\nLet's examine each in more detail. We'll use this vector as an example, to keep\nthings concise:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(a = 10, b = 20, c = 30, d = 40, e = 50)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n a  b  c  d  e \n10 20 30 40 50 \n```\n\n\n:::\n:::\n\n\nEven though we're using a vector here, the indexing operator works with almost\nall data structures, including factors, lists, matrices, and data frames. We'll\nlook at unique behavior for some of these later on.\n\n### All Elements {#sec-all-elements}\n\nThe first way to use `[` to select elements is to leave the index blank. This\nselects all elements:\n\n::: {.cell}\n\n```{.r .cell-code}\nx[]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n a  b  c  d  e \n10 20 30 40 50 \n```\n\n\n:::\n:::\n\n\nThis way of indexing is rarely used for getting elements, since it's the same\nas entering the variable name without the indexing operator. Instead, its main\nuse is for setting elements. Suppose we want to set all the elements of `x` to\n`5`. You might try writing this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = 5\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n:::\n\n\nRather than setting each element to `5`, this sets `x` to the scalar `5`, which\nis not what we want. Let's reset the vector and try again, this time using the\nindexing operator:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(a = 10, b = 20, c = 30, d = 40, e = 50)\nx[] = 5\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\na b c d e \n5 5 5 5 5 \n```\n\n\n:::\n:::\n\n\nAs you can see, now all the elements are `5`. So the indexing operator is\nnecessary to specify that we want to set the elements rather than the whole\nvariable.\n\nLet's reset `x` one more time, so that we can use it again in the next example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(a = 10, b = 20, c = 30, d = 40, e = 50)\n```\n:::\n\n\n### By Position\n\nThe second way to use `[` is to select elements by position. This happens when\nyou use an integer or numeric index. We already saw the basics of this in\n@sec-indexing-vectors.\n\nThe positions of the elements in a vector (or other data structure) correspond\nto numbers starting from 1 for the first element. This way of indexing is\nfrequently used together with the sequence operator `:` to get ranges of\nvalues. For instance, let's get the 2nd through 4th elements of `x`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[2:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n b  c  d \n20 30 40 \n```\n\n\n:::\n:::\n\n\nYou can also use this way of indexing to set specific elements or ranges of\nelements. For example, let's set the 3rd and 5th elements of `x` to `9` and\n`7`, respectively:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[c(3, 5)] = c(9, 7)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n a  b  c  d  e \n10 20  9 40  7 \n```\n\n\n:::\n:::\n\n\nWhen getting elements, you can repeat numbers in the index to get the same\nelement more than once. You can also use the order of the numbers to control\nthe order of the elements:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[c(2, 1, 2, 2)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n b  a  b  b \n20 10 20 20 \n```\n\n\n:::\n:::\n\n\nFinally, if the index contains only negative numbers, the elements at those\npositions are excluded rather than selected. For instance, let's get all\nelements except the 1st and 5th:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[-c(1, 5)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n b  c  d \n20  9 40 \n```\n\n\n:::\n:::\n\n\nWhen you index by position, the index should always be all positive or all\nnegative. Using a mix of positive and negative numbers causes R to emit error\nrather than returning elements, since it's unclear what the result should be:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[c(-1, 2)]\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in x[c(-1, 2)]: only 0's may be mixed with negative subscripts\n```\n\n\n:::\n:::\n\n\n### By Name\n\nThe third way to use `[` is to select elements by name. This happens when you\nuse a character vector as the index, and only works with named data structures.\n\nLike indexing by position, you can use indexing by name to get or set elements.\nYou can also use it to repeat elements or change the order. Let's get elements\n`a`, `c`, `d`, and `a` again from the vector `x`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny = x[c(\"a\", \"c\", \"d\", \"a\")]\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n a  c  d  a \n10  9 40 10 \n```\n\n\n:::\n:::\n\n\nElement names are generally unique, but if they're not, indexing by name gets\nor sets the first element whose name matches the index:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny[\"a\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n a \n10 \n```\n\n\n:::\n:::\n\n\nLet's reset `x` again to prepare for learning about the final way to index:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(a = 10, b = 20, c = 30, d = 40, e = 50)\n```\n:::\n\n\n### By Condition\n\nThe fourth and final way to use `[` is to select elements based on a condition.\nThis happens when you use a logical vector as the index. The logical vector\nshould have the same length as what you're indexing, and will be recycled if it\ndoesn't.\n\n#### Congruent Vectors {-}\n\nTo understand indexing by condition, we first need to learn about congruent\nvectors. Two vectors are **congruent** if they have the same length and they\ncorrespond element-by-element.\n\nFor example, suppose you do a survey that records each respondent's favorite\nanimal and age. These are two different vectors of information, but each person\nwill have a response for both. So you'll have two vectors that are the same\nlength:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanimal = c(\"dog\", \"cat\", \"iguana\")\nage = c(31, 24, 72)\n```\n:::\n\n\nThe 1st element of each vector corresponds to the 1st person, the 2nd to the\n2nd person, and so on. These vectors are congruent.\n\nNotice that columns in a data frame are always congruent!\n\n#### Back to Indexing {-}\n\nWhen you index by condition, the index should generally be congruent to the\nobject you're indexing. Elements where the index is `TRUE` are kept and\nelements where the index is `FALSE` are dropped.\n\nIf you create the index from a condition on the object, it's automatically\ncongruent. For instance, let's make a condition based on the vector `x`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_small = x < 25\nis_small\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    a     b     c     d     e \n TRUE  TRUE FALSE FALSE FALSE \n```\n\n\n:::\n:::\n\n\nThe 1st element in the logical vector `is_small` corresponds to the 1st element\nof `x`, the 2nd to the 2nd, and so on. The vectors `x` and `is_small` are\ncongruent.\n\nIt makes sense to use `is_small` as an index for `x`, and it gives us all the\nelements less than `25`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[is_small]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n a  b \n10 20 \n```\n\n\n:::\n:::\n\n\nOf course, you can also avoid using an intermediate variable for the condition:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[x > 10]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n b  c  d  e \n20 30 40 50 \n```\n\n\n:::\n:::\n\n\nIf you create index some other way (not using the object), make sure that it's\nstill congruent to the object. Otherwise, the subset returned from indexing\nmight not be meaningful.\n\nYou can also use indexing by condition to set elements, just as the other ways\nof indexing can be used to set elements. For instance, let's set all the\nelements of `x` that are greater than `10` to the missing value `NA`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[x > 10] = NA\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n a  b  c  d  e \n10 NA NA NA NA \n```\n\n\n:::\n:::\n\n\n\n### Logic {#sec-logic}\n\nAll of the conditions we've seen so far have been written in terms of a single\ntest. If you want to use more sophisticated conditions, R provides operators to\nnegate and combine logical vectors. These operators are useful for working with\nlogical vectors even outside the context of indexing.\n\n#### Negation {-}\n\nThe **NOT operator** `!` converts `TRUE` to `FALSE` and `FALSE` to `TRUE`:\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(TRUE, FALSE, TRUE, TRUE, NA)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE  TRUE  TRUE    NA\n```\n\n\n:::\n\n```{.r .cell-code}\n!x\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE FALSE    NA\n```\n\n\n:::\n:::\n\n\nYou can use `!` with a condition:\n\n::: {.cell}\n\n```{.r .cell-code}\ny = c(\"hi\", \"hello\")\n!(y == \"hi\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE\n```\n\n\n:::\n:::\n\n\nThe NOT operator is vectorized.\n\n\n#### Combinations {-}\n\nR also has operators for combining logical values.\n\nThe **AND operator** `&` returns `TRUE` only when both arguments are `TRUE`.\nHere are some examples:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nFALSE & FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nTRUE & FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nFALSE & TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nTRUE & TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nc(TRUE, FALSE, TRUE) & c(TRUE, TRUE, FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE FALSE\n```\n\n\n:::\n:::\n\n\nThe **OR operator** `|` returns `TRUE` when at least one argument is `TRUE`.\nLet's see some examples:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nFALSE | FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nTRUE | FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nFALSE | TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nTRUE | TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nc(TRUE, FALSE) | c(TRUE, TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE TRUE\n```\n\n\n:::\n:::\n\n\nBe careful: everyday English is less precise than logic. You might say:\n\n> I want all subjects with age over 50 and all subjects that like cats.\n\nBut in logic this means:\n\n`(subject age over 50) OR (subject likes cats)`\n\nSo think carefully about whether you need both conditions to be true (AND) or\nat least one (OR).\n\nRarely, you might want _exactly one_ condition to be true. The **XOR (eXclusive\nOR) function** `xor()` returns `TRUE` when exactly one argument is `TRUE`. For\nexample:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxor(FALSE, FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nxor(TRUE, FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nxor(TRUE, TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\nThe AND, OR, and XOR operators are vectorized.\n\n\n#### Short-circuiting {-}\n\nThe second argument is irrelevant in some conditions:\n\n* `FALSE &` is always `FALSE`\n* `TRUE |` is always `TRUE`\n\nNow imagine you have `FALSE & long_computation()`. You can save time by\nskipping `long_computation()`. A **short-circuit operator** does exactly that.\n\nR has two short-circuit operators:\n\n* `&&` is a short-circuited `&`\n* `||` is a short-circuited `|`\n\nThese operators only evaluate the second argument if it is necessary to\ndetermine the result. Here are some of these:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRUE && FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nTRUE && TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nTRUE || TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\nThe short-circuit operators are not vectorized---they only accept length-1\narguments:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(TRUE, FALSE) && c(TRUE, TRUE)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in c(TRUE, FALSE) && c(TRUE, TRUE): 'length = 2' in coercion to 'logical(1)'\n```\n\n\n:::\n:::\n\n\nBecause of this, you can't use short-circuit operators for indexing. Their main\nuse is in writing conditions for if-expressions, which we'll learn about later\non.\n\n:::{.callout-note}\nPrior to R 4.3.0, short-circuit operators didn't raise an error for inputs with\nlength greater than 1 (and thus were a common source of bugs).\n:::\n\n\nExercises\n---------\n\n### Exercise\n\nThe `rep` function is another way to create a vector. Read the help file for\nthe `rep` function.\n\n1. What does the `rep` function do to create a vector? Give an example.\n2. The `rep` function has parameters `times` and `each`. What does each do, and\n   how do they differ? Give examples for both.\n3. Can you set both of `times` and `each` in a single call to `rep`? If the\n   function raises an error, explain what the error message means. If the\n   function returns a result, explain how the result corresponds to the\n   arguments you chose.\n\n\n### Exercise\n\nConsidering how implicit coercion works (@sec-implicit-coercion):\n\n1. Why does `\"3\" + 4` raise an error?\n2. Why does `\"TRUE\" == TRUE` return `TRUE`?\n3. Why does `\"FALSE\" < TRUE` return TRUE?\n\n\n### Exercise\n\n1. @sec-missing-values described the missing value as a \"chameleon\" because it\n   can have many different types. Is `Inf` also a chameleon? Use examples to\n   justify your answer.\n\n2. The missing value is also \"contagious\" because using it as an argument\n   usually produces another missing value. Is `Inf` contagious? Again, use\n   examples to justify your answer.\n\n\n### Exercise\n\n1.  Create a new data frame from the least terns data with the following\n    characteristics:\n      * Each entry's year is between 2010 and 2019 (inclusive).\n      * Each entry reports at least 100 breeding pairs.\n      * The columns are `year`, `site_name`, `bp_min`, `bp_max`,\n        `total_nests`.\n\n    Use this data frame for the remaining questions.\n\n2.  Count the number of entries for each site. How many sites have at least 100\n    breeding pairs across all 10 years?\n\n3.  Which site-year combination has the highest number of nests?\n",
    "supporting": [
      "02_data-structures_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}